cmdhistory=[";; Switching to shl.service.conference namespace" "getActiveTournament" "(shl.service.conference.getActiveTournament)" "(* 1 2)" "shl.service.conference" "(addConference \\"test\\" 1)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'shl.service.conference)))" "when-not((and (\= 1 1) (< 1 2)) \\"true\\" \\"false\\")" "(and (\= 1 1) (< 1 2))" "(when-not (true) \\"true\\" \\"false\\")" "(when-not (1 < 2) \\"true\\" \\"false\\")" "(when-not (< 1 2) \\"true\\" \\"false\\")" "(def foo (when-not (< 1 2) \\"true\\" \\"false\\"))" "foo" "(def foo (if-not (< 1 2) \\"true\\" \\"false\\"))" "foo" "(def foo (if-not (< 2 1) \\"true\\" \\"false\\"))" "foo" "(every? ((< 1 2) (< 1 3)))" "(every? true ((< 1 2) (< 1 3)))" "(every? true? ((< 1 2) (< 1 3)))" "(every? true? '((< 1 2) (< 1 3)))" "(def statements '((< 1 2) (< 1 3)))" "statements" "(first statements)" "(true? (first statements))" "(< 1 2)" "(and (< 1 2) (< 1 3))" "(and (< 1 2) (< 1 3) (< 1 4))" "(and (< 1 2) (< 1 3) (>1 4))" "(and (< 1 2) (< 1 3) (> 1 4))" "(require shl.service.conference \:as dev)" " (use 'clj-time.core)" "(date-time 1986 10 14 4 3 27 456)" "(getActiveTournament [])" "shl.service.conference" "(require shl.service.conference \:as service)" "(shl.service.conference/getActiveTournament)" "(def db {\:subprotocol \\"postgresql\\" \:subname \\"//localhost\:5432/shl\\" \:db_user\=shl db_pass\=shl})" "(def db {\:subprotocol \\"postgresql\\" \:subname \\"//localhost\:5432/shl\\" \:db_user \\"shl\\" \:db_pass \\"shl\\"})" "(shl.service.conference/getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn (\:name \:active))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn (\:name \:active))" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(shl.service.conference/getActiveTournament)" "getActiveTournament" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn (\:active)))" "getActiveTournament" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    ))" "(getActiveTournament)" "(def foo getActiveTournament)" "foo" "(foo)" "(map fn [x] (x\:active) foo)" "(map fn [x] (\:active) foo)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#((\:name %) (\:active %)))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#((\:name %) (\:active %)))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "getActiveTournament" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(\:active %)))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn {\:active % \:name %}))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#({\:active % \:name %})))" "getActiveTournament" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(\:active % \:name %)))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "ActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \:name)" "ournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn {\:name \:" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn {\:name \:active}))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#({\:names (\:name %)})))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (assoc (j/query db \\n    (s/select * \:tournament (s/where {\:active true})))) \:startDate \\"foo\\" \:endDate \\"bar\\")\\n" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))))\\n" "(getActiveTournament)" "(def instant \#inst \\"2013-09-29T21\:00\:00.000-00\:00\\")" "(class (read-string instant))" "(class instant)" "(\= java.sql.Date (class instant))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active] \:tournament (s/where {\:active true}))))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select (\:name \:active) \:tournament (s/where {\:active true}))))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))))" "(foo)" "(defn foo [] \\n  (assoc getActiveTournament \:startDate \\"foo\\"))\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))))\\n" "(foo)" "(class (getActiveTournament))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \:name\\n    ))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startDate \\"foo\\") \\n    ))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate \\"foo\\") \\n    ))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/date-time 1986 10 14)) \\n    ))" "(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as s]\\n           [clj-time.core \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/date-time 1986 10 14)) \\n    ))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(defn addConference [name tournamentId]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentId}))\\r\\n\\r\\n\\n" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)) \\n    ))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(defn addConference [name tournamentId]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentId}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(defn addConference [name tournamentId]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentId}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)\\n                      \:endDate (time/from-sql-date (% \:endDate))\\n(clojure.core/ns user)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)\\n                      \:endDate (time/from-sql-date (% \:endDate))\\n    ))" "\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate))\\n                      \:endDate (time/from-sql-date (% \:endDate)))\\n    ))" "(shl.service.conference/getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate))\\n                      \:enddate (time/from-sql-date (% \:enddate)))\\n    ))\\n" "(shl.service.conference/getActiveTournament)" "(def foo (shl.service.conference/getActiveTournament))" "(foo)" "foo" "(\:enddate foo)" "(\:startdate foo)" "(get foo \:startdate)" "foo" "(get (first (foo) \:startdate))" "(get (first foo) \:startdate)" "(type (get (first foo) \:startdate))" "(defn getActiveTournament []\\r\\n  (j/query db \\r\\n    (s/select * \:tournament (s/where {\:active true}))\\r\\n    ))" "(type (get (first foo) \:startdate))" "(foo shl.service.conference/getActiveTournament)" "(def foo shl.service.conference/getActiveTournament)" "(type (get (first foo) \:startdate))" "foo" "(def foo (shl.service.conference/getActiveTournament))" "foo" "(type (get (first foo) \:startdate))" "(def key (type (get (first foo) \:startdate)))" "(def key2(type (get (first foo) \:startdate)))" "(\= \\"java.sql.Date\\" (type value))" "(\= \\"java.sql.Date\\" (type key2))" "(\= java.sql.Date (type key2))" "(\= (type java.sql.Date (type key2)))" "(\= (type java.sql.Date) (type key2))" "(shl.controllers.tournament/getActive)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament2 []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\n    ))\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament2)" "(shl.service.conference/getConferences 2)" "(shl.service.conference/get-active-tournament)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(defn get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql ))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(defn get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.conference/get-active-tournament)" "(shl.service.conference/get-conferences 2)" "(shl.service.conference/get-number-of-games-per-player 1)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(defn get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(defn get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.conference/get-number-of-games-per-player 1)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(-defn get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(-defn get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(-defn get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(ns)" "(namespace)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn- get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.db)\\n(ns shl.service.db)\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(clojure.core/ns user)" "shl.service.db/db" "(shl.service.conference/get-conferences 2)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by \:[id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-users)" "(shl.service.user/get-user 1)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-user 1)" "(shl.service.user/get-users)" "(shl.service.user/get-user \\"timovi\\")" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-tournament [name startdate enddate \\r\\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db/db \:tournament {\:name name \\r\\n                                \:startdate startdate\\r\\n                                \:enddate enddate\\r\\n                                \:gamesperplayer games-per-player\\r\\n                                \:playoffteamsperconference playoff-teams-per-conference\\r\\n                                \:active true}))\\r\\n\\r\\n(defn add-conference [name tournamentid]\\r\\n  (j/insert\! db/db \:conference {\:name name \\r\\n                                \:tournamentid tournamentid}))\\n\\n(defn inactivate-tournaments []\\n  (j/update\! db/db \:tournament {\:active false}))\\n\\n(defn- get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [[\:tournament \:t]] \\r\\n           \:where [\:\= \:t.active true]\\r\\n           \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (first (j/query db/db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    )))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n           \:where [\:\= \:c.id conferenceid]\\r\\n           \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db/db\\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:where [\:\= \:c.tournamentid tournamentid]\\r\\n           \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.conference/get-active-tournament)" "ns" "(ns)" "(ns shl.service.test\\r\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\r\\n           [clj-time.coerce \:as time]\\r\\n           [shl.service.db \:as db]))" "(j/where {\:foo \\"bar\\"})" "(s/where {\:foo \\"bar\\"})" "(require [clojure.java.jdbc.sql \:as sql])" "(ns shl.service.game\\r\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\r\\n           [clj-time.coerce \:as time]\\r\\n           [shl.service.db \:as db]))" "(sql/where {\:foo \\"bar\\" \:baz \\"fuzz\\"})" "(sql/where {\:foo \\"bar\\"} {\:baz \\"fuzz\\"})" "(sql/where [\:or {\:foo \\"bar\\"} {\:baz \\"fuzz\\"}])" "(defn remove-games-sql [playerid]\\n  (s/build \:delete \\n           \:from [[\:game \:g]]\\n           \:where [\:or [\:\= \:g.homeplayerid playerid] \\n                       [\:\= \:g.awayplayerid playerid]]))" "(shl.service.game/remove-games-sql)" "(shl.service.game/remove-games-sql 100\\n                                  )" "(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n" "(shl.service.game/get-games-sql \\"foo\\")" "(defn remove-games-sql [playerid]\\n  (s/build \:delete-from [[\:game \:g]]\\n           \:where [\:or [\:\= \:g.homeplayerid playerid] \\n                       [\:\= \:g.awayplayerid playerid]]))" "(shl.service.game/remove-games-sql \\"foo\\")" "(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))" "(shl.service.game/remove-games-sql \\"foo\\")" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerod]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (time/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql))))\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (time/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql))))\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql))))\\n\\n(clojure.core/ns user)" "(shl.service.game/remove-games 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select \:p.id\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n          \:from [[\:player \:p]]\\n          \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n          \:where [\:\= \:p.conferenceid conferenceid]\\n          \:order-by [\:u.lastname \:u.firstname])\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  s/build \:select \:p.id\\r\\n          \:from [[\:player \:p]]\\r\\n          \:where [\:\= \:p.conferenceid conferenceid]\\r\\n          \:order-by [\:p.id])\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-playerids 1)" "(shl.service.conference/get-conferences 1)" "(shl.service.conference/get-active-tournament)" "(shl.service.conference/get-conferences 2)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-users)" "(shl.service.user/get-roles)" "(shl.service.user/add-user samile Sami Leinonen 2)" "(shl.service.user/add-user \\"samile\\" \\"Sami\\" \\"Leinonen\\" 2)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user_ {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/add-user \\"samile\\" \\"Sami\\" \\"Leinonen\\" 2)" "(shl.service.user/get-users)" "(shl.service.user/add-user \\"juhaho\\" \\"Juha\\" \\"H\u00F6yss\u00E4\\" 2)" "(shl.service.user/add-user \\"teemuil\\" \\"Teemu\\" \\"Ilkka\\" 2)" "(shl.service.user/get-users)" "(shl.service.player/get-teams)" "(shl.service.player/add-team \\"Vancouver Canucks\\")" "(shl.service.player/add-team \\"Washington Capitals\\")" "(shl.service.player/add-team \\"Minnesota Wild\\")" "(shl.service.player/add-team \\"Boston Bruins\\")" "(shl.service.player/add-player 1 1 1)" "(shl.service.player/add-player 1 1 2)" "(shl.service.player/add-player 2 1 2)" "(shl.service.player/add-player 3 2 3)" "(shl.service.player/add-player 4 2 4)" "(shl.service.player/get-players 1)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(shl.service.player/get-playerids 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n          \:from [[\:player \:p]]\\n          \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n          \:where [\:\= \:p.conferenceid conferenceid]\\n          \:order-by [\:u.lastname \:u.firstname])\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  s/build \:select [\:p.id]\\r\\n          \:from [[\:player \:p]]\\r\\n          \:where [\:\= \:p.conferenceid conferenceid]\\r\\n          \:order-by [\:p.id])\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-teams)" "(shl.service.player/get-players 1)" "(shl.service.player/get-playerids 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n          \:from [[\:player \:p]]\\n          \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n          \:where [\:\= \:p.conferenceid conferenceid]\\n          \:order-by [\:u.lastname \:u.firstname])\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n          \:from [[\:player \:p]]\\r\\n          \:where [\:\= \:p.conferenceid conferenceid]\\r\\n          \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-playerids 1)" "(clojure.core/ns shl.service.player)\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-playerids 1)" "(shl.service.player/get-player-id 1 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:\= \:p.userid userid]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-player-id)" "(shl.service.player/get-player-id 1)" "(shl.service.player/get-player-id 1 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-player-id 1 1)" "(shl.service.player/get-playerids 1)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-player-id 1 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players-sql 1)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(shl.service.player/get-playerids 1)" "(shl.service.player/get-playerids 2)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:us.firstname \:us.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:us] [\:\= \:us.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:us.lastname \:us.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:us] [\:\= \:us.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:us.lastname \:us.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user_ {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-user \\"samile\\")" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:.*]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:*]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:*]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.*] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n                  [[\:team \:t] [\:\= \:t.id \:p.teamid]]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:merge-join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:merge-join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:merge-join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(shl.service.game/add-game 1 3)" "(shl.service.game/get-games 1)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(shl.service.game/remove-games 2)" "(shl.service.game/remove-games 3)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(defn- get-user-games-sql [userid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"] \\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hu.id userid]\\n                       [\:\= \:au.id userid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-conference-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-conference-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conference-games-sql conferenceid))))\\n\\n(defn- get-user-games-sql [userid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"] \\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hu.id userid]\\n                       [\:\= \:au.id userid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\r\\n(defn get-user-games [userid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-games-sql userid))))\\n(clojure.core/ns user)" "(shl.service.game/add-game 1 3)" "(shl.service.game/update-game 2 2 1 true false (clj-time.core/now))" "(shl.service.game/add-game 3 1)" "(shl.service.game/update-game 3 1 2 true true (clj-time.core/now))" "(shl.service.game/add-game 1 4)" "(shl.service.game/get-conference-games 1)" "(shl.service.game/get-user-games 1)" "(shl.service.game/get-user-games 3)" "(shl.service.user/get-users)" "(shl.service.game/get-user-games 2)" "(shl.service.game/remove-games 3)" "(shl.service.game/get-user-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-conference-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:hp.id \\"homeplayerid\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:ap.id \\"awayplayerid\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-conference-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conference-games-sql conferenceid))))\\n\\n(defn- get-user-games-sql [userid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"]\\n                    [\:hp.id \\"homeplayerid\\"]\\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:ap.id \\"awayplayerid\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hu.id userid]\\n                       [\:\= \:au.id userid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\r\\n(defn get-user-games [userid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-games-sql userid))))\\n(clojure.core/ns user)" "(shl.service.game/get-user-games 1)" "(shl.service.game/remove-games 1)" "(shl.service.game/get-conference-games 1)" "(shl.service.game/get-conference-games 2)" "(\= 1 1)" "(def a '(1 2 3))" "(a)" "a" "(first a)" "(rest a)" "(def formatter (clj-time.format/formatter \\"dd.MM.yyyy\\"))" "(def foo (clj-time.format/parse formatter \\"29.12.1983\\"))" "(foo)" "foo" "(clj-time.format/parse formatter \\"29.12.1983\\")" "(clj-time.format/parse formatter \\"foobar\\")" "(defn foo [x y]\\n  (let [z (* x 2)\\n        b (* y 3)]\\n    (+ z b)))" "(foo 1 1)" "(foo 2 1 )" "(defn bar [x]\\n  (let [z (* x 2)]\\n    (if (< z 4)\\n      (+ z))\\n    (z)))" "(bar 1)" "(defn bar [x y]\\r\\n     (let [z (* x 2)]\\r\\n       (if (< z 4)\\r\\n         (+ z))\\r\\n       (+ z y)))" "(bar 1 1)" "(bar 1 2)" "(bar 2 1)" "(clojure.core/ns shl.service.statistics)\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0 })\\n\\n(defn count-points [game]\\n  (let [player-won (> (get game \:player-goals) (get game \:opponent-goals))\\n        overtime (get game \:overtime)]\\n    (cond (and player-won (not overtime)) (get points \:win))\\n    (cond (and player-won overtime) (get points \:ot-win))\\n    (cond (and (not player-won) overtime) (get points \:ot-defeat))\\n    \: else (get points \:ot-defeat)))\\n(clojure.core/ns user)" "(def foo true)" "foo" "(not foo)" "(get points \:win)" "(def points {\:win 3 \\r\\n             \:ot-win 2 \\r\\n             \:ot-defeat 1\\r\\n             \:defeat 0 })" "(get points \:win)" "(> (get points \:win) (get points \:defeat))" "(and true true)" "(and true (not true))" "(clojure.core/ns shl.service.statistics)\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0})\\n\\n(defn count-points [game]\\n  (let [player-won (> (get game \:player-goals) (get game \:opponent-goals))\\n        overtime (get game \:overtime)]\\n    (cond (and player-won (not overtime)) (get points \:win))\\n    (cond (and player-won overtime) (get points \:ot-win))\\n    (cond (and (not player-won) overtime) (get points \:ot-defeat))\\n    \:else (get points \:defeat)))\\n(clojure.core/ns user)" "(def game {\:player-goals 10 \:opponent-goals 2 \:overtime false})" "(count-points game)" "(shl.service.statistics/count-points game)" "game" "(def game2 {\:player-goals 10 \:opponent-goals 2 \:overtime true})" "(shl.service.statistics/count-points game2)" "(def game3 {\:player-goals 1 \:opponent-goals 2 \:overtime true})" "(shl.service.statistics/count-points game3)" "(clojure.core/ns shl.service.statistics)\\n(defn count-points [game]\\n  (let [player-won (> (get game \:player-goals) (get game \:opponent-goals))\\n        overtime (get game \:overtime)]\\n    (cond \\n      (and player-won (not overtime)) (get points \:win)\\n      (and player-won overtime) (get points \:ot-win)\\n      (and (not player-won) overtime) (get points \:ot-defeat)\\n      \:else (get points \:defeat))))\\n(clojure.core/ns user)" "(shl.service.statistics/count-points game)" "(shl.service.statistics/count-points game2)" "(shl.service.statistics/count-points game3)" "(clojure.core/ns shl.service.statistics)\\n(defn count-points [game]\\n  (let [player-won (> (get game \:player-goals) (get game \:opponent-goals))\\n        overtime (get game \:overtime)]\\n    (cond \\n      (and player-won (not overtime)) \:win\\n      (and player-won overtime) \:ot-win\\n      (and (not player-won) overtime) \:ot-defeat\\n      \:else \:defeat)))\\n(clojure.core/ns user)" "(shl.service.statistics/count-points game)" "(def games [{\:home-player 1 \:away-player 2 \:home-goals 3 \:away-goals 2 \:overtime false \:playdate\: true}\\r\\n{\:home-player 1 \:away-player 3 \:home-goals 1 \:away-goals 2 \:overtime true \:playdate\: true}\\r\\n{\:home-player 3 \:away-player 2 \:home-goals 5 \:away-goals 1 \:overtime false \:playdate\: true}])\\r\\n(def players [1 2 3])" "(def games [{\:home-player 1 \:away-player 2 \:home-goals 3 \:away-goals 2 \:overtime false \:playdate true}\\r\\n{\:home-player 1 \:away-player 3 \:home-goals 1 \:away-goals 2 \:overtime true \:playdate true}\\r\\n{\:home-player 3 \:away-player 2 \:home-goals 5 \:away-goals 1 \:overtime false \:playdate true}])\\r\\n(def players [1 2 3])" "(players)" "players" "(def home-games (group-by \:home-player games))" "home-games" "(def numberonegames (select 1 home-games))" "(def numberonegames (get 1 home-games))" "numberonegames" "(def numberonegames (get home-games 1))" "numberonegames" "(def numberonestatus (get-game-statuses numberonegames true))" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\n\\n;;(defn get-player-statistics [playerid]\\n;;  (let [games (game/get-player-games playerid)])\\n;;  (let [home-games ()\\n;;  )\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn get-game-status [game]\\n  (let [player-won (> (get game \:player-goals) (get game \:opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) \:not-played\\n      (and player-won (not overtime)) \:win\\n      (and player-won overtime) \:ot-win\\n      (and (not player-won) overtime) \:ot-defeat\\n      \:else \:defeat)))\\n\\n(defn get-game-statuses [games home]\\n  (map \#(get-game-status %) games))\\n\\n(defn get-player-games [home-games away-games])\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (map \#((get-game-statuses (get home-games %) true) home-games) players)\\n    ))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(def numberonestatus (shl.service.statistics/get-game-statuses numberonegames true))" "numberonestatus" "numberonegames" "(clojure.core/ns shl.service.statistics)\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\n\\n;;(defn get-player-statistics [playerid]\\n;;  (let [games (game/get-player-games playerid)])\\n;;  (let [home-games ()\\n;;  )\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn get-game-status [game]\\n  (let [player-won (> (get game \:home-goals) (get game \:away-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) \:not-played\\n      (and player-won (not overtime)) \:win\\n      (and player-won overtime) \:ot-win\\n      (and (not player-won) overtime) \:ot-defeat\\n      \:else \:defeat)))\\n\\n(defn get-game-statuses [games home]\\n  (map \#(get-game-status %) games))\\n\\n(defn get-player-games [home-games away-games])\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (map \#((get-game-statuses (get home-games %) true) home-games) players)\\n    ))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-game-statuses numberonegames true)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\n\\n;;(defn get-player-statistics [playerid]\\n;;  (let [games (game/get-player-games playerid)])\\n;;  (let [home-games ()\\n;;  )\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn get-game-status [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) \:not-played\\n      (and player-won (not overtime)) \:win\\n      (and player-won overtime) \:ot-win\\n      (and (not player-won) overtime) \:ot-defeat\\n      \:else \:defeat)))\\n\\n(defn get-game-statuses [games home]\\n  (map \#(get-game-status %) games))\\n\\n(defn get-player-games [home-games away-games])\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (map \#((get-game-statuses (get home-games %) true) home-games) players)\\n    ))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-game-statuses numberonegames true)" "numberonegames" "(def games [{\:home-player 1 \:away-player 2 \:home-goals 3 \:away-goals 2 \:overtime false \:playdate true}\\r\\n{\:home-player 1 \:away-player 3 \:home-goals 1 \:away-goals 2 \:overtime true \:playdate true}\\r\\n{\:home-player 2 \:away-player 1 \:home-goals 4 \:away-goals 3 \:overtime true \:playdate true}\\r\\n{\:home-player 3 \:away-player 2 \:home-goals 5 \:away-goals 1 \:overtime false \:playdate true}])" "(def home-games (group-by \:home-playery games))" "home-games" "games" "(def home-games (group-by \:home-player games))" "home-games" "(def home-games (group-by \:home-player games))\\r\\n(def away-games (group-by \:away-player games))\\r\\n(def numonehomegames (get home-games 1))" "numonehomegames" "(def numonehomestatuses (shl.service.statistics/get-game-statuses numonehomegames true))" "numonehomestatuses" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\n\\n;;(defn get-player-statistics [playerid]\\n;;  (let [games (game/get-player-games playerid)])\\n;;  (let [home-games ()\\n;;  )\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn get-game-status [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) \:not-played\\n      (and player-won (not overtime)) \:win\\n      (and player-won overtime) \:ot-win\\n      (and (not player-won) overtime) \:ot-defeat\\n      \:else \:defeat)))\\n\\n(defn get-game-statuses [games home]\\n  (map \#(get-game-status %) games))\\n\\n(defn get-player-games [home-games away-games])\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (map \#((get-game-statuses (get home-games %) true) home-games) players)\\n    ))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(def numonehomestatuses (shl.service.statistics/get-game-statuses numonehomegames true))" "numonehomestatuses" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\n\\n;;(defn get-player-statistics [playerid]\\n;;  (let [games (game/get-player-games playerid)])\\n;;  (let [home-games ()\\n;;  )\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn get-game-status [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) \:not-played\\n      (and player-won (not overtime)) \:win\\n      (and player-won overtime) \:ot-win\\n      (and (not player-won) overtime) \:ot-defeat\\n      \:else \:defeat)))\\n\\n(defn get-game-statuses [games home]\\n  (map \#(get-game-status % home) games))\\n\\n(defn get-player-games [home-games away-games])\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (map \#((get-game-statuses (get home-games %) true) home-games) players)\\n    ))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(def numonehomestatuses (shl.service.statistics/get-game-statuses numonehomegames true))" "numonehomestatuses" "numonehomegames" "(def foo (1 2 3))" "(def foo [1 2 3])" "(def bar [2 3 4])" "(merge foo bar)" "(merge-with concat foo bar)" "(def foo {\:a [1 2] \:b [2 3]})" "(def bar {b\: [1 1]})" "(def bar {\:b [1 1]})" "(merge foo bar)" "(merge-with concat foo bar)" "(def foo 2)" "(def foo [\:win \:win \:ot-win \:defeat \:ot-win \:win \:ot-win \:defeat])" "(group-by count foo)" "(count foo)" "(distinct foo)" "(count (distinct foo))" "(map foo)" "(filter \:win foo)" "foo" "(def points {\:win 3 \\r\\n             \:ot-win 2 \\r\\n             \:ot-defeat 1\\r\\n             \:defeat 0\\r\\n             \:not-played 0})" "(get \:win points)" "(get points \:win)" "(clojure.core/ns shl.service.statistics)\\n(defn map-game-result [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.statistics)\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game-result [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n(clojure.core/ns user)" "(map-game-result \:win 2 1)" "(shl.service.statistics/map-game-result \:win 2 1)" "(clojure.core/ns shl.dao.conference)\\n(defn- get-active-tournament-sql []\\r\\n  (first\\n    (s/build \:select \:* \\r\\n             \:from [[\:tournament \:t]] \\r\\n             \:where [\:\= \:t.active true]\\r\\n             \:order-by [[\:t.id \:desc]])))\\n(clojure.core/ns user)" "(clojure.core/ns shl.dao.conference)\\n(ns shl.dao.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.dao.db \:as db]))\\n\\n(defn add-tournament [name startdate enddate \\r\\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db/db \:tournament {\:name name \\r\\n                                \:startdate (time/to-sql-date startdate)\\r\\n                                \:enddate (time/to-sql-date enddate)\\r\\n                                \:gamesperplayer games-per-player\\r\\n                                \:playoffteamsperconference playoff-teams-per-conference\\r\\n                                \:active true}))\\r\\n\\r\\n(defn add-conference [name tournamentid]\\r\\n  (j/insert\! db/db \:conference {\:name name \\r\\n                                \:tournamentid tournamentid}))\\n\\n(defn inactivate-tournaments []\\n  (j/update\! db/db \:tournament {\:active false}))\\n\\n(defn- get-active-tournament-sql []\\r\\n  (first\\n    (s/build \:select \:* \\r\\n             \:from [[\:tournament \:t]] \\r\\n             \:where [\:\= \:t.active true]\\r\\n             \:order-by [[\:t.id \:desc]])))\\n\\n(defn get-active-tournament []\\r\\n  (first \\n    (j/query db/db \\r\\n       (s/format (get-active-tournament-sql))\\r\\n       \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                         \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    )))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n           \:where [\:\= \:c.id conferenceid]\\r\\n           \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db/db\\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:where [\:\= \:c.tournamentid tournamentid]\\r\\n           \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.dao.conference/get-active-tournament)" "(clojure.core/ns shl.dao.conference)\\n(ns shl.dao.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.dao.db \:as db]))\\n\\n(defn add-tournament [name startdate enddate \\r\\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db/db \:tournament {\:name name \\r\\n                                \:startdate (time/to-sql-date startdate)\\r\\n                                \:enddate (time/to-sql-date enddate)\\r\\n                                \:gamesperplayer games-per-player\\r\\n                                \:playoffteamsperconference playoff-teams-per-conference\\r\\n                                \:active true}))\\r\\n\\r\\n(defn add-conference [name tournamentid]\\r\\n  (j/insert\! db/db \:conference {\:name name \\r\\n                                \:tournamentid tournamentid}))\\n\\n(defn inactivate-tournaments []\\n  (j/update\! db/db \:tournament {\:active false}))\\n\\n(defn get-active-tournament-sql []\\r\\n  (first\\n    (s/build \:select \:* \\r\\n             \:from [[\:tournament \:t]] \\r\\n             \:where [\:\= \:t.active true]\\r\\n             \:order-by [[\:t.id \:desc]])))\\n\\n(defn get-active-tournament []\\r\\n  (first \\n    (j/query db/db \\r\\n       (s/format (get-active-tournament-sql))\\r\\n       \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                         \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    )))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n           \:where [\:\= \:c.id conferenceid]\\r\\n           \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db/db\\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:where [\:\= \:c.tournamentid tournamentid]\\r\\n           \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.dao.conference/get-active-tournament-sql)" "(def foo shl.dao.conference/get-active-tournament-sql)" "foo" "(def foo (shl.dao.conference/get-active-tournament-sql))" "foo" "(honeysql.core/build foo)" "(honeysql.core/format foo)" "(clojure.core/ns shl.dao.conference)\\n(ns shl.dao.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.dao.db \:as db]))\\n\\n(defn add-tournament [name startdate enddate \\r\\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db/db \:tournament {\:name name \\r\\n                                \:startdate (time/to-sql-date startdate)\\r\\n                                \:enddate (time/to-sql-date enddate)\\r\\n                                \:gamesperplayer games-per-player\\r\\n                                \:playoffteamsperconference playoff-teams-per-conference\\r\\n                                \:active true}))\\r\\n\\r\\n(defn add-conference [name tournamentid]\\r\\n  (j/insert\! db/db \:conference {\:name name \\r\\n                                \:tournamentid tournamentid}))\\n\\n(defn inactivate-tournaments []\\n  (j/update\! db/db \:tournament {\:active false}))\\n\\n(defn get-active-tournament-sql []\\n    (s/build \:select \:* \\r\\n             \:from [[\:tournament \:t]] \\r\\n             \:where [\:\= \:t.active true]\\r\\n             \:order-by [[\:t.id \:desc]]))\\n\\n(defn get-active-tournament []\\r\\n  (first \\n    (j/query db/db \\r\\n       (s/format (get-active-tournament-sql))\\r\\n       \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                         \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    )))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n           \:where [\:\= \:c.id conferenceid]\\r\\n           \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db/db\\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:where [\:\= \:c.tournamentid tournamentid]\\r\\n           \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.dao.conference/get-active-tournament)" "(clojure.core/ns shl.dao.game)\\n(ns shl.dao.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-conference-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:hp.id \\"homeplayerid\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:ap.id \\"awayplayerid\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-conference-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conference-games-sql conferenceid))))\\n\\n(defn- get-player-games-sql [playerid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"]\\n                    [\:hp.id \\"homeplayerid\\"]\\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:ap.id \\"awayplayerid\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hp.id playerid]\\n                       [\:\= \:ap.id playerid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\r\\n(defn get-player-games [playerid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-player-games-sql playerid))\\n    \:row-fn \#(assoc % \:playdate (str (time/from-sql-date (% \:playdate)))\\r\\n                      \:modifieddate (str (time/from-sql-date (% \:modifieddate)))) \\n   ))\\n\\n(defn- get-player-game-results-sql [playerid]\\r\\n  (s/build \:select [\:g.homegoals \:g.awaygoals \:g.overtime\\r\\n                    [\:hp.id \\"homeplayerid\\"]\\r\\n                    [\:ap.id \\"awayplayerid\\"]]  \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:where [\:and [\:<\= \:g.playdate (time/to-sql-date (t/now))]\\n                        [\:or [\:\= \:hp.id playerid]\\r\\n                             [\:\= \:ap.id playerid]]]\\r\\n           \:order-by [\:g.id]))\\r\\n\\r\\n(defn get-player-game-results [playerid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-player-game-results-sql playerid))))\\n(clojure.core/ns user)" "(shl.dao.game/get-conference-games 1)" "(shl.dao.game/get-player-game-results 2)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (concat\\n       (map (get-game-results (get home-games playerid) true))\\n       (map (get-game-results (get away-games playerid) false)))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)])) \\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 2)" "(shl.service.statistics/get-player-standings 2)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)])) \\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 2)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:home-player games)\\n        away-games (group-by \:away-player games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 2)" "(def players (shl.dao.player/get-playerids 1))" "players" "(shl.dao.game/add-game 1 3)" "(shl.dao.game/add-game 3 1)" "(def games (shl.dao.game/get-conference-games 1))" "games" "(def home-games (group-by \:home-player games))" "home-games" "(def home-games (group-by \:homeplayerid games))" "home-games" "(shl.service.statistics/get-conference-standings 1)" "(def home-results (map \#((get-game-results (get home-games %) true) home-games) players))" "(clojure.core/ns shl.service.statistics)\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(def home-results (map \#((get-game-results (get home-games %) true) home-games) players))" "(def home-results (map \#((shl.service.statisticsget-game-results (get home-games %) true) home-games) players))" "\=> (def home-results (map \#((shl.service.statistics/get-game-results (get home-games %) true) home-games) players))" "home-results" "(def player1games (get 1 home-games))" "player1games" "home-games" "(get 1 home-games)" "(get home-games 1)" "(shl.service.statistics/get-game-results (get home-games 1) true)" "(get home-games 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn get-game-result [game home]\\n  (let [player-goals (if home \:home-goals \:away-goals)\\n        opponent-goals (if home \:away-goals \:home-goals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-game-result (first player1games) true)" "(first player1games)" "player1games" "home-games" "(def player1games (get home-games 1))" "player1games" "(get-game-result (first player1games) true)" "(shl.service.statistics/get-game-result (first player1games) true)" "(first player1games)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn get-game-result [game home]\\n  (let [player-goals (if home \:homegoals \:awaygoals)\\n        opponent-goals (if home \:awaygoals \:homegoals)\\n        player-won (> (get game player-goals) (get game opponent-goals))\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-game-result (first player1games) true)" "(first player1games)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn- map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn get-game-result [game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (get game player-goals-key)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (get game opponent-goals-key)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (and (nil? playdate)) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n       (map \#((get-game-results (get home-games %) true) home-games) players)\\n       (map \#((get-game-results (get away-games %) false) away-games) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "\=> (shl.service.statistics/get-game-result (first player1games) true)" "(shl.service.statistics/get-game-result (first player1games) true)" "(clojure.core/ns shl.service.statistics)\\n(defn map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(clojure.core/ns user)" "(shl.service.statistics/map-game \:not-played 0 0)" "(def playdate (get (first player1games) \:playdate))" "playdate" "(def player-goals (get (first player1games) \:homegoals))" "player-goals" "(def opponent-goals (get (first player1games) \:awaygoals))" "opponent-goals" "(def player-won (> player-goals opponent-goals))" "(clojure.core/ns shl.service.statistics)\\n(defn get-game-result [game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n(clojure.core/ns user)" "(shl.service.statistics/get-game-result (first player1games) true)" "(shl.service.statistics/get-conference-standings 1)" "(shl.service.statistics/get-player-standings 1)" "(shl.dao.game/get-player-games 1)" "(shl.service.statistics/get-player-standings 1)" "(shl.dao.game/get-player-games 1)" "(shl.service.statistics/get-player-standings 1)" "(shl.service.statistics/get-conference-standings 1)" "(def players shl.dao.player/get-playerids 1)" "(def players (shl.dao.player/get-playerids 1))" "(def games (shl.dao.game/get-conference-games 1))" "players" "games" "(def home-games (group-by \:homeplayerid games))" "(def away-games (groupby \:awayplayerid games))" "(def away-games (group-by \:awayplayerid games))" "away-games" "home-games" "(shl.service.statistics/get-game-results (get home-games 1) true)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    players\\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    games\\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (map \#((get-game-results (get home-games %) true) home-games) players)\\n    \\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (map \#((get-game-results (get home-games %) true)) players)\\n    \\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (map \#(get-game-results (get home-games %) true) players)\\n    \\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (map (fn [player] (get-game-results (get home-games player) true)) players)\\n    \\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (map (fn [player] player) players)\\n    \\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (map (fn [player] (get-game-results (get home-games (get player \:id)) true)) players)\\n    \\n    ))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn get-game-result [game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n      (map (fn [player] (get-game-results (get home-games (get player \:id)) true)) players)\\n      (map (fn [player] (get-game-results (get home-games (get player \:id)) true)) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [result goals-scored goals-let]\\n  {\:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn get-game-result [game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game \:defeat player-goals opponent-goals))))\\n\\n(defn get-game-results [games home]\\n  (map \#(get-game-result % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n      (map (fn [player] (get-game-results (get home-games (get player \:id)) true)) players)\\n      (map (fn [player] (get-game-results (get away-games (get player \:id)) true)) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(def mappeja [{\:a 1 \:b 2}, {\:a 2 \:b 2}, {\:a 1 \:b 3}])" "mappeja" "(filter (\= a 1) mappeja)" "\=> (filter (\= \:a 1) mappeja)" "(filter (\= \:a 1) mappeja)" "(filter \#(\= (get % \:a) 1) mappeja)" "(filter \#(\= (% \:a) 1) mappeja)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n      (map (fn [player] (get-game-results (get home-games (player \:id)) true)) players)\\n      (map (fn [player] (get-game-results (get away-games (player \:id)) true)) players)\\n    )))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)]\\n    (concat\\n      (map (fn [player] (get-game-results (get home-games (player \:id)) true)) players)\\n      (map (fn [player] (get-game-results (get away-games (player \:id)) true)) players)\\n    )))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n      (map (fn [player] (get-game-results (get home-games (player \:id)) true)) players)\\n      (map (fn [player] (get-game-results (get away-games (player \:id)) true)) players)\\n    )))\\n\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n      (map \#(get-game-results (get home-games (% \:id)) true) players)\\n      (map \#(get-game-results (get away-games (% \:id)) true) players)\\n    )))\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-player-conference-games [playerid conference-games]\\n  (concat \\n    (filter \#(\= (% \:homeplayerid) playerid) conference-games)\\n    (filter \#(\= (% \:homeplayerid) playerid) conference-games)))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n      (map \#(get-game-results (get home-games (% \:id)) true) players)\\n      (map \#(get-game-results (get away-games (% \:id)) true) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (merge-with concat\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results (get home-games playerid) true)\\n       (get-game-results (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-conference-standings 1)" "(shl.service.statistics/get-player-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)\\n        results (get-player-game-results playerid games)]\\n    results))\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-standings [playerid]\\n  (let [games (game-dao/get-player-games playerid)]\\n    (get-player-game-results playerid games)))\\n\\n\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\n        games (game-dao/get-conference-games conferenceid)\\n        home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\n    )))\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 1)" "(def games shl.service.statistics/get-player-standings 1)" "\=> (def games (shl.service.statistics/get-player-standings 1))" "(def games (shl.service.statistics/get-player-standings 1))" "games" "(reduce fn[a b] ({\:playerid (a \:playerid), \:goals-scored (+ (a \:goals-scored) (b \:goals-scored)) } ) games)" "((first games))" "((first games) \:goals-scored)" "(reduce (fn[a b] {\:playerid (a \:playerid), \:goals-scored (+ (a \:goals-scored) (b \:goals-scored)) }) games)" "games" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-stats [playerid]\\r\\n  (let [games (game-dao/get-player-games playerid)]\\r\\n    (get-player-game-results playerid games)))\\r\\n\\r\\n\\r\\n(defn get-conference-stats [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\n\\n\\r\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] {\:playerid (prev \:playerid), \\n                      \:wins (if (\= (curr \:result) \:win) (inc (prev \:wins))\\n                      \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n                      \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n                      \:points (+ (prev \:points) (curr \:points))\\n                      }) games)))\\r\\n\\r\\n\\r\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\r\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-stats 1)" "games" "(reduce \\r\\n      (fn[prev curr] {\:playerid (prev \:playerid)\\r\\n                      \:wins (if (\= (curr \:result) \:win) (inc (prev \:wins)))\\r\\n                      \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\r\\n                      \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\r\\n                      \:points (+ (prev \:points) (curr \:points))\\r\\n                      }) games)" "    (reduce \\r\\n      (fn[prev curr] {\:playerid (prev \:playerid)\\r\\n                      \:wins (if (\= (curr \:result) \:win) (inc (prev \:wins)))\\r\\n                      \:not-played (if (\= (curr \:result) \:not-played) (inc (prev \:not-played)))\\r\\n                      \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\r\\n                      \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\r\\n                      \:points (+ (prev \:points) (curr \:points))\\r\\n                      }) games)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-stats [playerid]\\r\\n  (let [games (game-dao/get-player-games playerid)]\\r\\n    (get-player-game-results playerid games)))\\r\\n\\r\\n\\r\\n(defn get-conference-stats [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\n\\n\\r\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] {\:playerid (prev \:playerid)\\n                      \:wins (if (\= (curr \:result) \:win) (inc (prev \:wins)))\\n                      \:not-played (if (\= (curr \:result) \:not-played) (inc (prev \:not-played)))\\n                      \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n                      \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n                      \:points (+ (prev \:points) (curr \:points))\\n                      }) \\n      {\:playerid playerid \:wins 0 \:ot-wins 0 \:ot-defeats 0 \:defeats 0 \:not-played 0}\\n      games)))\\r\\n\\r\\n\\r\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\r\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.statistics)\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] {\:playerid (prev \:playerid)\\n                      \:wins (if (\= (curr \:result) \:win) (inc (prev \:wins)))\\n                      \:not-played (if (\= (curr \:result) \:not-played) (inc (prev \:not-played)))\\n                      \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n                      \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n                      \:points (+ (prev \:points) (curr \:points))\\n                      }) \\n      {\:playerid playerid \:wins 0 \:ot-wins 0 \:ot-defeats 0 \:defeats 0 \:not-played 0}\\n      stats)))\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 1)" "(inc 1)" "(inc (first games) \:not-played)" "(inc ((first games) \:not-played))" "(def result ((first games) \:result))" "result" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-stats [playerid]\\r\\n  (let [games (game-dao/get-player-games playerid)]\\r\\n    (get-player-game-results playerid games)))\\r\\n\\r\\n\\r\\n(defn get-conference-stats [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\n\\n(defn inc-result [prev curr result-key]\\n  (if (\= (curr \:result) result-key) \\n    (inc (prev result-key)) \\n    (prev result-key)))\\n\\r\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] \\n        {\:playerid (prev \:playerid)\\n         \:wins (inc-result prev curr \:win)\\n         \:not-played (inc-result prev curr \:not-played)\\n         \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n         \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n         \:points (+ (prev \:points) (curr \:points))\\n        }) \\n      {\:playerid playerid \:wins 0 \:ot-wins 0 \:ot-defeats 0 \:defeats 0 \:not-played 0}\\n      stats)))\\r\\n\\r\\n\\r\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\r\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 1)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-stats [playerid]\\r\\n  (let [games (game-dao/get-player-games playerid)]\\r\\n    (get-player-game-results playerid games)))\\r\\n\\r\\n\\r\\n(defn get-conference-stats [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\n\\n(defn inc-result [prev curr result-key]\\n  (if (\= (curr \:result) result-key) \\n    (inc (prev result-key)) \\n    (prev result-key)))\\n\\r\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] \\n        {\:playerid (prev \:playerid)\\n         \:win (inc-result prev curr \:win)\\n         \:ot-win (inc-result prev curr \:ot-win)\\n         \:ot-defeat (inc-result prev curr \:ot-defeat)\\n         \:defeat (inc-result prev curr \:defeat)\\n         \:not-played (inc-result prev curr \:not-played)\\n         \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n         \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n         \:points (+ (prev \:points) (curr \:points))\\n        }) \\n      {\:playerid playerid \:win 0 \:ot-win 0 \:ot-defeat 0 \:defeat 0 \:not-played 0}\\n      stats)))\\r\\n\\r\\n\\r\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\r\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 1)" "(def foo1 {\:result \:win})" "(def foo2 {\:result \:win})" "(def foo3 {\:result \:defeat})" "foo1" "foo2" "foo3" "(shl.service.statistics/inc-result foo1 foo2 \:win)" "(inc foo1 \:win)" "(inc (foo1 \:win))" "(foo1 \:win)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-stats [playerid]\\r\\n  (let [games (game-dao/get-player-games playerid)]\\r\\n    (get-player-game-results playerid games)))\\r\\n\\r\\n\\r\\n(defn get-conference-stats [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\n\\n(defn inc-result [prev curr result-key]\\n  (if (\= (curr \:result) result-key) \\n    (inc (prev result-key)) \\n    (prev \:result)))\\n\\r\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] \\n        {\:playerid (prev \:playerid)\\n         \:win (inc-result prev curr \:win)\\n         \:ot-win (inc-result prev curr \:ot-win)\\n         \:ot-defeat (inc-result prev curr \:ot-defeat)\\n         \:defeat (inc-result prev curr \:defeat)\\n         \:not-played (inc-result prev curr \:not-played)\\n         \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n         \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n         \:points (+ (prev \:points) (curr \:points))\\n        }) \\n      {\:playerid playerid \:win 0 \:ot-win 0 \:ot-defeat 0 \:defeat 0 \:not-played 0}\\n      stats)))\\r\\n\\r\\n\\r\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\r\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/get-player-standings 1)" "(def init {\:playerid playerid \:win 0 \:ot-win 0 \:ot-defeat 0 \:defeat 0 \:not-played 0})" "(def init {\:playerid 1 \:win 0 \:ot-win 0 \:ot-defeat 0 \:defeat 0 \:not-played 0})" "(shl.service.statistics/inc-result init foo1)" "(shl.service.statistics/inc-result init foo1 \:win)" "(shl.service.statistics/inc-result init foo1 \:defeat)" "(clojure.core/ns shl.service.statistics)\\n(ns shl.service.statistics\\n  (require [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.dao.game \:as game-dao]\\n           [shl.dao.player \:as player-dao]))\\r\\n\\n(def points {\:win 3 \\n             \:ot-win 2 \\n             \:ot-defeat 1\\n             \:defeat 0\\n             \:not-played 0})\\n\\n(defn map-game [playerid result goals-scored goals-let]\\n  {\:playerid playerid\\n   \:result result \\n   \:goals-scored goals-scored\\n   \:goals-let goals-let\\n   \:points (get points result)})\\n\\n(defn- get-game-result [playerid game home]\\n  (let [player-goals-key (if home \:homegoals \:awaygoals)\\n        player-goals (or (get game player-goals-key) 0)\\n        opponent-goals-key (if home \:awaygoals \:homegoals)\\n        opponent-goals (or (get game opponent-goals-key) 0)\\n        player-won (> player-goals opponent-goals)\\n        overtime (get game \:overtime)\\n        playdate (get game \:playdate)]\\n    (cond \\n      (nil? playdate) (map-game playerid \:not-played 0 0) \\n      (and player-won (not overtime)) (map-game playerid \:win player-goals opponent-goals)\\n      (and player-won overtime) (map-game playerid \:ot-win player-goals opponent-goals)\\n      (and (not player-won) overtime) (map-game playerid \:ot-defeat player-goals opponent-goals)\\n      \:else (map-game playerid \:defeat player-goals opponent-goals))))\\n\\n(defn- get-game-results [playerid games home]\\n  (map \#(get-game-result playerid % home) games))\\n\\n(defn- get-player-game-results [playerid games]\\n  (let [home-games (group-by \:homeplayerid games)\\n        away-games (group-by \:awayplayerid games)]\\n    (concat\\n       (get-game-results playerid (get home-games playerid) true)\\n       (get-game-results playerid (get away-games playerid) false))))\\n\\n(defn get-player-stats [playerid]\\r\\n  (let [games (game-dao/get-player-games playerid)]\\r\\n    (get-player-game-results playerid games)))\\r\\n\\r\\n\\r\\n(defn get-conference-stats [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\n\\n(defn inc-result [prev curr result-key]\\n  (if (\= (curr \:result) result-key) \\n    (inc (prev result-key)) \\n    (prev result-key)))\\n\\r\\n(defn get-player-standings [playerid]\\r\\n  (let [stats (get-player-stats playerid)]\\r\\n    (reduce \\n      (fn[prev curr] \\n        {\:playerid (prev \:playerid)\\n         \:win (inc-result prev curr \:win)\\n         \:ot-win (inc-result prev curr \:ot-win)\\n         \:ot-defeat (inc-result prev curr \:ot-defeat)\\n         \:defeat (inc-result prev curr \:defeat)\\n         \:not-played (inc-result prev curr \:not-played)\\n         \:goals-scored (+ (prev \:goals-scored) (curr \:goals-scored)) \\n         \:goals-let (+ (prev \:goals-let) (curr \:goals-let))\\n         \:points (+ (prev \:points) (curr \:points))\\n        }) \\n      {\:playerid playerid \:win 0 \:ot-win 0 \:ot-defeat 0 \:defeat 0 \:not-played 0}\\n      stats)))\\r\\n\\r\\n\\r\\n(defn get-conference-standings [conferenceid]\\r\\n  (let [players (player-dao/get-playerids conferenceid)\\r\\n        games (game-dao/get-conference-games conferenceid)\\r\\n        home-games (group-by \:homeplayerid games)\\r\\n        away-games (group-by \:awayplayerid games)]\\r\\n    (concat\\r\\n      (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)\\r\\n      (map \#(get-game-results (% \:id) (get away-games (% \:id)) true) players)\\r\\n    )))\\r\\n\\r\\n(defn get-tournament-standings [tournamentid]\\r\\n  true)\\n(clojure.core/ns user)" "(shl.service.statistics/inc-result init foo1 \:defeat)" "(shl.service.statistics/inc-result init foo1 \:win)" "(shl.service.statistics/get-player-standings 1)" "(shl.dao.conference/get-conferences 5)" "(shl.dao.conference/get-active-tournament)" "(shl.dao.conference/get-number-of-games-per-player 3)" "(shl.dao.player/get-player-id 1 4)" "(shl.dao.player/get-playerids 4)" "(shl.dao.conference/get-number-of-games-per-player 4)" "(shl.service.game/add-games 1 4)" "(shl.dao.player/get-playerids)" "(shl.dao.player/get-player-id 4)" "(shl.dao.player/get-playerids 4)" "(shl.dao.player/get-player-id 1 4)" "(let [players (shl.dao.player/get-playerids 4)])" "(players)" "(def players (shl.dao.player/get-playerids 4))" "(players)" "players" "(map \:id players)" "(def player (first players))" "player" "(map \:id player)" "(\:id player)" "(shl.service.game/add-games 1 4)" "(shl.dao.conference/get-number-of-games-per-player 4)" "(shl.service.game/add-games 1 4)" "(\:gamesperplayer (shl.dao.conference/get-number-of-games-per-player 4))" "(shl.dao.conference/get-number-of-games-per-player 4)" "(shl.dao.player/get-player-id 1 4)" "(shl.service.game/add-games 1 4)" ";; Switching to shl.service.game namespace" "(add-games 1 4)" "(player-dao/get-player-id 1 4)" "(def playerid (\:id (player-dao/get-player-id 1 4)))" "playerid" "(def players (map \:id (player-dao/get-playerids 4)))" "players" "(def game-count (\:gamesperplayer (conference-dao/get-number-of-games-per-player 4)))" "game-count" "(add-games2 playerid players game-count)" "(empty? players)" "(add-games3 6 7 true 2)" "(add-games 1 4)" "(shl.dao.player/remove-player 6)" "(shl.dao.game/remove-games 6)" "(add-games3 6 7 2)" "(- 2)" "(- 2 1)" "(- 4 1)" "(add-games3 6 7)" "(add-games 6 7 2)" "(add-games3 6 7 2)" "(add-games 1 4)" "(game-dao)" ";; Switching to shl.service.game namespace" "(conference-dao/get-active-tournament)" "(conference-dao/get-conferences 5)" "(player-dao/get-players 4)" "(game-dao/get-player-games 6)" "(game-dao/get-conference-games 4)" "(add-games 1 4)" "(get-conference-games)" ";; Switching to shl.controllers.game namespace" "(get-conference-games 4)" "(get-conference-games \\"4\\")" ";; Switching to shl.controllers.statistics namespace" ";; Switching to shl.service.statistics namespace" "(get-player-stats 1)" "(get-player-stats 6)" "(get-player-standings 6)" "(get-conference-stats 4)" "(get-conference-standings 4)" "(get-conference-stats 4)" "(get-conference-standings 4)" "(get-player-stats 1)" "(get-player-stats 6)" "(get-player-standings 6)" "(get-conference-stats 4)" "(def foo (get-conference-stats 4))" "foo" "(filter (\= 6 \:playerid) foo)" "(filter \#((\= 6 (get \:playerid %)) foo))" "(filter \#((\= 6 (get \:playerid %))) foo)" "(filter \#(\= 6 (get \:playerid %)) foo)" "foo" "(get \:playerid foo)" "(get foo \:playerid)" "(\:playerid foo)" "(filter \#(\= 6 (get % \:playerid)) foo)" "foo" "(foo)" "(first foo)" "(filter \#(\= 6 (get % \:playerid)) foo)" "(get (first foo) \:playerid)" "(get \:playerid (first foo))" "(first foo)" "(\:playerid (first foo))" "((first foo) \:playerid)" "(def foo1 (first foo))" "foo1" "(get foo1 \:playerid)" "(def bar {\:a 1 \:b 2})" "bar" "foo1" "foo" "(get-conference-stats 4)" "(get-conference-standings 4)" "(get-conference-stats 4)" "(game-dao/get-conference-games 4)" "foo" "(concat (1 2) (5 4))" "(def players (player-dao/get-playerids 4))" "(def games (game-dao/get-conference-games 4))" "(def home-games (group-by \:homeplayerid games))" "home-games" "(get home-games 8)" "(get home-games 6)" "(map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players)" "(def mapped-games (map \#(get-game-results (% \:id) (get home-games (% \:id)) true) players))" "mapped-games" "(map-cat mapped-games)" "(mapcat mapped-games)" "mapped-games" "(first mapped-games)" "(calculate-player-standings (first mapped-games) 6)" "games" "(first get-conference-stats 4)" "(first (get-conference-stats 4))" "(get (first (get-conference-stats 4)) \:playerid)" "((first (get-conference-stats 4)) \:playerid)" "(first (get-conference-stats 4) \:playerid)" "(\:playerid (first (get-conference-stats 4)))" "((first (get-conference-stats 4)) \:playerid)" "(first (get-conference-stats 4))" "((first (first (get-conference-stats 4))) \:playerid)" "(def foobar (get-conference-stats 4))" "(calculate-conference-standings foobar)" "(calculate-player-standings (first foobar) ((first (first foobar)) \:playerid))" "(conj 1 2)" "(conj nil 1)" "(rest (1))" "(rest [1])" "(conj () 1)" "(calculate-conference-standings foobar)" "\=> (conj [] 1)" "\=> (calculate-conference-standings foobar)" "(get-conference-standings 4)" "\=> (get-conference-standings 4)" ";; Switching to shl.service.statistics namespace" "(get-tournament-standings 5)" ";; Switching to shl.dao.conference namespace" "(get-conferenceids 5)" ";; Switching to shl.service.statistics namespace" "\=> (get-tournament-standings 5)" ";; Switching to shl.controllers.team namespace" ";; Switching to shl.controllers.tournament namespace"]
eclipse.preferences.version=1
