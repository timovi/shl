cmdhistory=[";; Switching to shl.service.conference namespace" "getActiveTournament" "(shl.service.conference.getActiveTournament)" "(* 1 2)" "shl.service.conference" "(addConference \\"test\\" 1)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'shl.service.conference)))" "when-not((and (\= 1 1) (< 1 2)) \\"true\\" \\"false\\")" "(and (\= 1 1) (< 1 2))" "(when-not (true) \\"true\\" \\"false\\")" "(when-not (1 < 2) \\"true\\" \\"false\\")" "(when-not (< 1 2) \\"true\\" \\"false\\")" "(def foo (when-not (< 1 2) \\"true\\" \\"false\\"))" "foo" "(def foo (if-not (< 1 2) \\"true\\" \\"false\\"))" "foo" "(def foo (if-not (< 2 1) \\"true\\" \\"false\\"))" "foo" "(every? ((< 1 2) (< 1 3)))" "(every? true ((< 1 2) (< 1 3)))" "(every? true? ((< 1 2) (< 1 3)))" "(every? true? '((< 1 2) (< 1 3)))" "(def statements '((< 1 2) (< 1 3)))" "statements" "(first statements)" "(true? (first statements))" "(< 1 2)" "(and (< 1 2) (< 1 3))" "(and (< 1 2) (< 1 3) (< 1 4))" "(and (< 1 2) (< 1 3) (>1 4))" "(and (< 1 2) (< 1 3) (> 1 4))" "(require shl.service.conference \:as dev)" " (use 'clj-time.core)" "(date-time 1986 10 14 4 3 27 456)" "(getActiveTournament [])" "shl.service.conference" "(require shl.service.conference \:as service)" "(shl.service.conference/getActiveTournament)" "(def db {\:subprotocol \\"postgresql\\" \:subname \\"//localhost\:5432/shl\\" \:db_user\=shl db_pass\=shl})" "(def db {\:subprotocol \\"postgresql\\" \:subname \\"//localhost\:5432/shl\\" \:db_user \\"shl\\" \:db_pass \\"shl\\"})" "(shl.service.conference/getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn (\:name \:active))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn (\:name \:active))" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(shl.service.conference/getActiveTournament)" "getActiveTournament" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn (\:active)))" "getActiveTournament" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    ))" "(getActiveTournament)" "(def foo getActiveTournament)" "foo" "(foo)" "(map fn [x] (x\:active) foo)" "(map fn [x] (\:active) foo)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#((\:name %) (\:active %)))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#((\:name %) (\:active %)))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "getActiveTournament" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(\:active %)))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn {\:active % \:name %}))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#({\:active % \:name %})))" "getActiveTournament" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(\:active % \:name %)))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "(getActiveTournament)" "(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))" "ActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \:name)" "ournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn {\:name \:" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn {\:name \:active}))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#({\:names (\:name %)})))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (assoc (j/query db \\n    (s/select * \:tournament (s/where {\:active true})))) \:startDate \\"foo\\" \:endDate \\"bar\\")\\n" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))))\\n" "(getActiveTournament)" "(def instant \#inst \\"2013-09-29T21\:00\:00.000-00\:00\\")" "(class (read-string instant))" "(class instant)" "(\= java.sql.Date (class instant))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active] \:tournament (s/where {\:active true}))))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select (\:name \:active) \:tournament (s/where {\:active true}))))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))))" "(foo)" "(defn foo [] \\n  (assoc getActiveTournament \:startDate \\"foo\\"))\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))))\\n" "(foo)" "(class (getActiveTournament))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \:name\\n    ))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startDate \\"foo\\") \\n    ))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate \\"foo\\") \\n    ))" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/date-time 1986 10 14)) \\n    ))" "(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as s]\\n           [clj-time.core \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/date-time 1986 10 14)) \\n    ))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(defn addConference [name tournamentId]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentId}))\\r\\n\\r\\n\\n" "(getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)) \\n    ))" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(defn addConference [name tournamentId]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentId}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(defn addConference [name tournamentId]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentId}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select [\:name \:active \:startDate] \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n(defn addTournament [name startDate endDate gamesPerPlayer playoffTeamsPerConference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startDate startDate\\n                             \:endDate endDate\\n                             \:gamesPerPlayer gamesPerPlayer\\n                             \:playoffTeamsPerConference playoffTeamsPerConference\\n                             \:active true}))\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.conference)\\n(defn getConferences [tournamentId]\\r\\n  (j/query db\\r\\n    (s/select * \:conference (s/where {\:tournamentId tournamentId}))))\\n\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)))\\n    ))\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)\\n                      \:endDate (time/from-sql-date (% \:endDate))\\n(clojure.core/ns user)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate)\\n                      \:endDate (time/from-sql-date (% \:endDate))\\n    ))" "\\n(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate))\\n                      \:endDate (time/from-sql-date (% \:endDate)))\\n    ))" "(shl.service.conference/getActiveTournament)" "(defn getActiveTournament []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (time/from-sql-date (% \:startdate))\\n                      \:enddate (time/from-sql-date (% \:enddate)))\\n    ))\\n" "(shl.service.conference/getActiveTournament)" "(def foo (shl.service.conference/getActiveTournament))" "(foo)" "foo" "(\:enddate foo)" "(\:startdate foo)" "(get foo \:startdate)" "foo" "(get (first (foo) \:startdate))" "(get (first foo) \:startdate)" "(type (get (first foo) \:startdate))" "(defn getActiveTournament []\\r\\n  (j/query db \\r\\n    (s/select * \:tournament (s/where {\:active true}))\\r\\n    ))" "(type (get (first foo) \:startdate))" "(foo shl.service.conference/getActiveTournament)" "(def foo shl.service.conference/getActiveTournament)" "(type (get (first foo) \:startdate))" "foo" "(def foo (shl.service.conference/getActiveTournament))" "foo" "(type (get (first foo) \:startdate))" "(def key (type (get (first foo) \:startdate)))" "(def key2(type (get (first foo) \:startdate)))" "(\= \\"java.sql.Date\\" (type value))" "(\= \\"java.sql.Date\\" (type key2))" "(\= java.sql.Date (type key2))" "(\= (type java.sql.Date (type key2)))" "(\= (type java.sql.Date) (type key2))" "(shl.controllers.tournament/getActive)" "(clojure.core/ns shl.service.conference)\\n(defn getActiveTournament2 []\\n  (j/query db \\n    (s/select * \:tournament (s/where {\:active true}))\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\n    ))\\n(clojure.core/ns user)" "(shl.service.conference/getActiveTournament2)" "(shl.service.conference/getConferences 2)" "(shl.service.conference/get-active-tournament)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(defn get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql ))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(defn get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.conference/get-active-tournament)" "(shl.service.conference/get-conferences 2)" "(shl.service.conference/get-number-of-games-per-player 1)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(defn get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(defn get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.conference/get-number-of-games-per-player 1)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(-defn get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(-defn get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(-defn get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(ns)" "(namespace)" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]))\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(defn- get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n          \:from [[\:tournament \:t]] \\r\\n          \:where [\:\= \:t.active true]\\r\\n          \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (j/query db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    ))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n          \:where [\:\= \:c.id conferenceid]\\r\\n          \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db \\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn add-tournament [name startdate enddate \\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db \:tournament {\:name name \\n                             \:startdate startdate\\n                             \:enddate enddate\\n                             \:gamesperplayer games-per-player\\n                             \:playoffteamsperconference playoff-teams-per-conference\\n                             \:active true}))\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n          \:from [[\:conference \:c]]\\r\\n          \:where [\:\= \:c.tournamentid tournamentid]\\r\\n          \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\n(defn add-conference [name tournamentid]\\n  (j/insert\! db \:conference {\:name name \\n                             \:tournamentid tournamentid}))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.db)\\n(ns shl.service.db)\\n\\n;(def db {\:subprotocol (System/getenv \\"DB_TYPE\\")\\r\\n;         \:subname (System/getenv \\"DB_URL\\")\\r\\n;         \:user (System/getenv \\"DB_USER\\")\\r\\n;         \:password (System/getenv \\"DB_PASS\\")})\\n\\n(def db {\:subprotocol \\"postgresql\\" \\n         \:subname \\"//localhost\:5432/shl\\" \\n         \:user \\"shl\\" \\n         \:password \\"shl\\"})\\r\\n\\n(clojure.core/ns user)" "shl.service.db/db" "(shl.service.conference/get-conferences 2)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by \:[id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-users)" "(shl.service.user/get-user 1)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-user 1)" "(shl.service.user/get-users)" "(shl.service.user/get-user \\"timovi\\")" "(clojure.core/ns shl.service.conference)\\n(ns shl.service.conference\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-tournament [name startdate enddate \\r\\n                      games-per-player playoff-teams-per-conference]\\r\\n  (j/insert\! db/db \:tournament {\:name name \\r\\n                                \:startdate startdate\\r\\n                                \:enddate enddate\\r\\n                                \:gamesperplayer games-per-player\\r\\n                                \:playoffteamsperconference playoff-teams-per-conference\\r\\n                                \:active true}))\\r\\n\\r\\n(defn add-conference [name tournamentid]\\r\\n  (j/insert\! db/db \:conference {\:name name \\r\\n                                \:tournamentid tournamentid}))\\n\\n(defn inactivate-tournaments []\\n  (j/update\! db/db \:tournament {\:active false}))\\n\\n(defn- get-active-tournament-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [[\:tournament \:t]] \\r\\n           \:where [\:\= \:t.active true]\\r\\n           \:order-by [\:t.id]))\\n\\n(defn get-active-tournament []\\r\\n  (first (j/query db/db \\r\\n    (s/format (get-active-tournament-sql))\\r\\n    \:row-fn \#(assoc % \:startdate (str (time/from-sql-date (% \:startdate)))\\r\\n                      \:enddate (str (time/from-sql-date (% \:enddate))))\\r\\n    )))\\n\\n(defn- get-number-of-games-per-player-sql [conferenceid]\\r\\n  (s/build \:select \:t.gamesperplayer \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:join [[\:tournament \:t] [\:\= \:c.tournamentid \:t.id]] \\r\\n           \:where [\:\= \:c.id conferenceid]\\r\\n           \:order-by [\:t.id]))\\r\\n\\n(defn get-number-of-games-per-player [conferenceid]\\n  (j/query db/db\\r\\n    (s/format (get-number-of-games-per-player-sql conferenceid))\\r\\n    ))\\r\\n\\n(defn- get-conferences-sql [tournamentid]\\r\\n  (s/build \:select [\:name \:id] \\r\\n           \:from [[\:conference \:c]]\\r\\n           \:where [\:\= \:c.tournamentid tournamentid]\\r\\n           \:order-by [\:c.id]))\\n\\n(defn get-conferences [tournamentid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conferences-sql tournamentid))\\r\\n    ))\\r\\n\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.conference/get-active-tournament)" "ns" "(ns)" "(ns shl.service.test\\r\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\r\\n           [clj-time.coerce \:as time]\\r\\n           [shl.service.db \:as db]))" "(j/where {\:foo \\"bar\\"})" "(s/where {\:foo \\"bar\\"})" "(require [clojure.java.jdbc.sql \:as sql])" "(ns shl.service.game\\r\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\r\\n           [clj-time.coerce \:as time]\\r\\n           [shl.service.db \:as db]))" "(sql/where {\:foo \\"bar\\" \:baz \\"fuzz\\"})" "(sql/where {\:foo \\"bar\\"} {\:baz \\"fuzz\\"})" "(sql/where [\:or {\:foo \\"bar\\"} {\:baz \\"fuzz\\"}])" "(defn remove-games-sql [playerid]\\n  (s/build \:delete \\n           \:from [[\:game \:g]]\\n           \:where [\:or [\:\= \:g.homeplayerid playerid] \\n                       [\:\= \:g.awayplayerid playerid]]))" "(shl.service.game/remove-games-sql)" "(shl.service.game/remove-games-sql 100\\n                                  )" "(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n" "(shl.service.game/get-games-sql \\"foo\\")" "(defn remove-games-sql [playerid]\\n  (s/build \:delete-from [[\:game \:g]]\\n           \:where [\:or [\:\= \:g.homeplayerid playerid] \\n                       [\:\= \:g.awayplayerid playerid]]))" "(shl.service.game/remove-games-sql \\"foo\\")" "(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))" "(shl.service.game/remove-games-sql \\"foo\\")" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerod]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (time/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql))))\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (time/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql))))\\n\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql))))\\n\\n(clojure.core/ns user)" "(shl.service.game/remove-games 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select \:p.id\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n          \:from [[\:player \:p]]\\n          \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n          \:where [\:\= \:p.conferenceid conferenceid]\\n          \:order-by [\:u.lastname \:u.firstname])\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  s/build \:select \:p.id\\r\\n          \:from [[\:player \:p]]\\r\\n          \:where [\:\= \:p.conferenceid conferenceid]\\r\\n          \:order-by [\:p.id])\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-playerids 1)" "(shl.service.conference/get-conferences 1)" "(shl.service.conference/get-active-tournament)" "(shl.service.conference/get-conferences 2)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-users)" "(shl.service.user/get-roles)" "(shl.service.user/add-user samile Sami Leinonen 2)" "(shl.service.user/add-user \\"samile\\" \\"Sami\\" \\"Leinonen\\" 2)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user_ {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/add-user \\"samile\\" \\"Sami\\" \\"Leinonen\\" 2)" "(shl.service.user/get-users)" "(shl.service.user/add-user \\"juhaho\\" \\"Juha\\" \\"H\u00F6yss\u00E4\\" 2)" "(shl.service.user/add-user \\"teemuil\\" \\"Teemu\\" \\"Ilkka\\" 2)" "(shl.service.user/get-users)" "(shl.service.player/get-teams)" "(shl.service.player/add-team \\"Vancouver Canucks\\")" "(shl.service.player/add-team \\"Washington Capitals\\")" "(shl.service.player/add-team \\"Minnesota Wild\\")" "(shl.service.player/add-team \\"Boston Bruins\\")" "(shl.service.player/add-player 1 1 1)" "(shl.service.player/add-player 1 1 2)" "(shl.service.player/add-player 2 1 2)" "(shl.service.player/add-player 3 2 3)" "(shl.service.player/add-player 4 2 4)" "(shl.service.player/get-players 1)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(shl.service.player/get-playerids 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n          \:from [[\:player \:p]]\\n          \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n          \:where [\:\= \:p.conferenceid conferenceid]\\n          \:order-by [\:u.lastname \:u.firstname])\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  s/build \:select [\:p.id]\\r\\n          \:from [[\:player \:p]]\\r\\n          \:where [\:\= \:p.conferenceid conferenceid]\\r\\n          \:order-by [\:p.id])\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-teams)" "(shl.service.player/get-players 1)" "(shl.service.player/get-playerids 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n          \:from [[\:player \:p]]\\n          \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n          \:where [\:\= \:p.conferenceid conferenceid]\\n          \:order-by [\:u.lastname \:u.firstname])\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n          \:from [[\:player \:p]]\\r\\n          \:where [\:\= \:p.conferenceid conferenceid]\\r\\n          \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-playerids 1)" "(clojure.core/ns shl.service.player)\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [[\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-playerids 1)" "(shl.service.player/get-player-id 1 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:\= \:p.userid userid]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-player-id)" "(shl.service.player/get-player-id 1)" "(shl.service.player/get-player-id 1 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-player-id 1 1)" "(shl.service.player/get-playerids 1)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    s/format (get-players-sql conferenceid)))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    s/format (get-playerids-sql conferenceid)))\\n(clojure.core/ns user)" "(shl.service.player/get-player-id 1 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players-sql 1)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(shl.service.player/get-playerids 1)" "(shl.service.player/get-playerids 2)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:us.firstname \:us.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:us] [\:\= \:us.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:us.lastname \:us.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:p.id \:u.firstname \:u.lastname \:t.name]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:us] [\:\= \:us.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:us.lastname \:us.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.user)\\n(ns shl.service.user\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-user [username firstname lastname roleid]\\r\\n  (j/insert\! db/db \:user_ {\:username username \\r\\n                          \:firstname firstname\\r\\n                          \:lastname lastname\\r\\n                          \:roleid roleid}))\\n\\r\\n(defn- get-roles-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:role]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-roles []\\r\\n  (j/query db/db \\r\\n    (s/format (get-roles-sql))))\\n\\n(defn- get-role-id-sql [rolename]\\r\\n  (s/build \:select \:r.id \\r\\n           \:from [[\:role \:r]] \\r\\n           \:where [\:\= \:r.name rolename]))\\n\\n(defn get-role-id []\\r\\n  (j/query db/db \\r\\n    (s/format (get-role-id-sql))))\\n\\r\\n(defn- get-users-sql []\\r\\n  (s/build \:select \:* \\r\\n           \:from [\:user_]\\n           \:order-by [\:id]))\\r\\n\\r\\n(defn get-users []\\r\\n  (j/query db/db \\r\\n    (s/format (get-users-sql))))\\n\\n(defn- get-user-sql [username]\\r\\n  (s/build \:select [\:u.* [\:r.name \\"role\\"]] \\r\\n           \:from [[\:user_ \:u]]\\n           \:join [[\:role \:r] [\:\= \:r.id \:u.roleid]]\\n           \:where [\:\= \:u.username username]))\\r\\n\\r\\n(defn get-user [username]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-sql username))))\\r\\n\\n\\n(clojure.core/ns user)" "(shl.service.user/get-user \\"samile\\")" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:.*]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:*]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [\:*]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.*] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n                  [[\:team \:t] [\:\= \:t.id \:p.teamid]]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:merge-join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.player)\\n(ns shl.service.player\\n  (require [clojure.java.jdbc \:as j]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [shl.service.db \:as db]))\\n\\n(defn add-team [name]\\r\\n  (j/insert\! db/db \:team {\:name name}))\\n\\n(defn add-player [userid conferenceid teamid]\\r\\n  (j/insert\! db/db \:player {\:userid userid\\n                            \:conferenceid conferenceid\\n                            \:teamid teamid}))\\n\\n(defn remove-player [playerid]\\n  (j/delete\! \:player (j/where {\:id playerid})))\\n\\r\\n(defn- get-teams-sql []\\r\\n  (s/build \:select [\:*] \\r\\n           \:from [\:team]\\n           \:order-by [\:id]))\\r\\n\\n(defn get-teams []\\r\\n  (j/query db/db \\r\\n    (s/format (get-teams-sql))))\\n\\n(defn- get-player-id-sql [userid conferenceid]\\n  (s/build \:select [\:p.id]\\n           \:from [[\:player \:p]]\\n           \:where [\:and [\:\= \:p.userid userid] [\:\= \:p.conferenceid conferenceid]]\\n           \:order-by [\:p.id]\\n           \:limit 1))\\n\\n(defn get-player-id [userid conferenceid]\\n  (first (j/query db/db\\n    (s/format (get-player-id-sql userid conferenceid)))))\\n\\n(defn- get-players-sql [conferenceid]\\n  (s/build \:select [[\:p.id \\"id\\"] \\n                    [\:u.firstname \\"firstname\\"] \\n                    [\:u.lastname \\"lastname\\"] \\n                    [\:t.name \\"team\\"]]\\n           \:from [[\:player \:p]]\\n           \:merge-join [[\:user_ \:u] [\:\= \:u.id \:p.userid]]\\n           \:merge-join [[\:team \:t] [\:\= \:t.id \:p.teamid]]\\n           \:where [\:\= \:p.conferenceid conferenceid]\\n           \:order-by [\:u.lastname \:u.firstname]))\\n\\n(defn get-players [conferenceid]\\n  (j/query db/db\\n    (s/format (get-players-sql conferenceid))))\\n\\n(defn- get-playerids-sql [conferenceid]\\r\\n  (s/build \:select [\:p.id]\\r\\n           \:from [[\:player \:p]]\\r\\n           \:where [\:\= \:p.conferenceid conferenceid]\\r\\n           \:order-by [\:p.id]))\\r\\n\\r\\n(defn get-playerids [conferenceid]\\r\\n  (j/query db/db\\r\\n    (s/format (get-playerids-sql conferenceid))))\\n(clojure.core/ns user)" "(shl.service.player/get-players 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [[\:\= \:hp.conferenceid conferenceid]]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(shl.service.game/add-game 1 3)" "(shl.service.game/get-games 1)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate playdate\\n                    \:modifieddate (t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date t/now)}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:hu.id \:hu.firstname \:hu.lastname \:ht.name\\n                    \:au.id \:au.firstname \:au.lastname \:at.name\\n                    \:g.homegoals \:g.awaygoals \:g.overtime \:g.shootout\\n                    \:g.playdate \:g.modifieddate] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/update-game 1 10 2 false false (clj-time.core/now))" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-games-sql conferenceid))))\\n\\n(clojure.core/ns user)" "(shl.service.game/get-games 1)" "(shl.service.game/remove-games 2)" "(shl.service.game/remove-games 3)" "(shl.service.game/get-games 1)" "(clojure.core/ns shl.service.game)\\n(defn- get-user-games-sql [userid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"] \\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hu.id userid]\\n                       [\:\= \:au.id userid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\n(clojure.core/ns user)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-conference-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-conference-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conference-games-sql conferenceid))))\\n\\n(defn- get-user-games-sql [userid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"] \\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hu.id userid]\\n                       [\:\= \:au.id userid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\r\\n(defn get-user-games [userid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-games-sql userid))))\\n(clojure.core/ns user)" "(shl.service.game/add-game 1 3)" "(shl.service.game/update-game 2 2 1 true false (clj-time.core/now))" "(shl.service.game/add-game 3 1)" "(shl.service.game/update-game 3 1 2 true true (clj-time.core/now))" "(shl.service.game/add-game 1 4)" "(shl.service.game/get-conference-games 1)" "(shl.service.game/get-user-games 1)" "(shl.service.game/get-user-games 3)" "(shl.service.user/get-users)" "(shl.service.game/get-user-games 2)" "(shl.service.game/remove-games 3)" "(shl.service.game/get-user-games 1)" "(clojure.core/ns shl.service.game)\\n(ns shl.service.game\\n  (require [clojure.java.jdbc \:as j]\\n           [clojure.java.jdbc.sql \:as sql]\\r\\n           [honeysql.core \:as s]\\n           [clj-time.coerce \:as time]\\n           [clj-time.core \:as t]\\n           [shl.service.db \:as db]))\\n\\n(defn add-game [home-playerid away-playerid]\\r\\n  (j/insert\! db/db \:game {\:homeplayerid home-playerid\\n                          \:awayplayerid away-playerid}))\\n\\n(defn remove-games-sql [playerid]\\n  (s/format {\:delete-from \:game\\n             \:where [\:or [\:\= \:homeplayerid playerid] \\n                         [\:\= \:awayplayerid playerid]]}))\\n\\n;; Using the traditional sql-string because \\n;; a) honeySql doesn't yet support DELETE clause\\n;; b) clojure jdbc doesn't support OR clauses in it's own API\\n(defn remove-games [playerid]\\n  (j/execute\! db/db \\n    [\\"DELETE FROM game g WHERE g.homeplayerid \= ? OR g.awayplayerid \= ?\\" playerid playerid]))\\n\\n(defn update-game [gameid home-goals away-goals overtime shootout playdate]\\n  (j/update\! db/db \\n             \:game {\:homegoals home-goals\\n                    \:awaygoals away-goals\\n                    \:overtime overtime\\n                    \:shootout shootout\\n                    \:playdate (time/to-sql-date playdate)\\n                    \:modifieddate (time/to-sql-date (t/now))}\\n             (sql/where {\:id gameid})))\\n\\r\\n(defn- get-conference-games-sql [conferenceid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\n                    [\:hu.id \\"homeuserid\\"] \\n                    [\:hu.firstname \\"homefirstname\\"] \\n                    [\:hu.lastname \\"homelastname\\"]\\n                    [\:hp.id \\"homeplayerid\\"]\\n                    [\:ht.name \\"hometeam\\"]\\n                    [\:au.id \\"awayuserid\\"] \\n                    [\:au.firstname \\"awayfirstname\\"] \\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:ap.id \\"awayplayerid\\"]\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\n           \:where [\:\= \:hp.conferenceid conferenceid]\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\n(defn get-conference-games [conferenceid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-conference-games-sql conferenceid))))\\n\\n(defn- get-user-games-sql [userid]\\r\\n  (s/build \:select [\:g.id \:g.homegoals \:g.awaygoals \\r\\n                    \:g.overtime \:g.shootout\\r\\n                    \:g.playdate \:g.modifieddate\\r\\n                    [\:hu.id \\"homeuserid\\"]\\n                    [\:hp.id \\"homeplayerid\\"]\\r\\n                    [\:hu.firstname \\"homefirstname\\"] \\r\\n                    [\:hu.lastname \\"homelastname\\"]\\r\\n                    [\:ht.name \\"hometeam\\"]\\r\\n                    [\:au.id \\"awayuserid\\"] \\r\\n                    [\:au.firstname \\"awayfirstname\\"] \\r\\n                    [\:au.lastname \\"awaylastname\\"]\\n                    [\:ap.id \\"awayplayerid\\"]\\r\\n                    [\:at.name \\"awayteam\\"]] \\r\\n           \:from [[\:game \:g]]\\r\\n           \:join [[\:player \:hp][\:\= \:g.homeplayerid \:hp.id]]\\r\\n           \:merge-join [[\:user_ \:hu][\:\= \:hp.userid \:hu.id]]\\r\\n           \:merge-join [[\:team \:ht][\:\= \:hp.teamid \:ht.id]]\\r\\n           \:merge-join [[\:player \:ap][\:\= \:g.awayplayerid \:ap.id]]\\r\\n           \:merge-join [[\:user_ \:au][\:\= \:ap.userid \:au.id]]\\r\\n           \:merge-join [[\:team \:at][\:\= \:ap.teamid \:at.id]]\\r\\n           \:where [\:or [\:\= \:hu.id userid]\\n                       [\:\= \:au.id userid]]\\r\\n           \:order-by [\:hu.lastname \:hu.firstname \:au.lastname \:au.firstname]))\\r\\n\\r\\n(defn get-user-games [userid]\\r\\n  (j/query db/db \\r\\n    (s/format (get-user-games-sql userid))))\\n(clojure.core/ns user)" "(shl.service.game/get-user-games 1)" "(shl.service.game/remove-games 1)" "(shl.service.game/get-conference-games 1)" "(shl.service.game/get-conference-games 2)"]
eclipse.preferences.version=1
